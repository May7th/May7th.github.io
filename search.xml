<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Maven]]></title>
      <url>%2F2017%2F04%2F25%2FMaven%2F</url>
      <content type="text"><![CDATA[Maven简介Maven是什么？Apache Maven Project — Apache的优秀开源项目， 基于项目对象模型，可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。 Maven能干什么？ 用Maven可以方便的创建项目，基于archetype可以创建多种类型的java项目。 Maven仓库对jar包（artifact）进行统一管理，避免jar文件的重复拷贝和版本冲突。 团队开发，Maven管理项目的RELEASSE和SNAPSHOT版本，方便多模块的项目中，各个模块之间的快速集成。 Maven常见命令 mvn命令 含义 -v 查看Maven版本 compile 编译项目 test 测试项目 package 打包项目 clean 删除target install 将jar包安装到本地仓库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【java基础知识】并发]]></title>
      <url>%2F2017%2F04%2F17%2F%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%E5%B9%B6%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[编程问题中相当大的部分都可以通过顺序编程来解决，但是对于一些问题，如果能够并行地执行程序中的多个部分，就会变得非常方便。 假如想要一个程序运行的更快，那么就应该将其分成多个片段，在单独的处理器上运行每个片段来提高速度。但是，并发通常也可以提高单处理器 运行程序的性能。 ​ 由于增加了上下文切换的代价，在单处理器上并发运行的开销其实是要比顺序运行的开销更大的，但是，在顺序运行时可能会有其他更严重的问题——程序阻塞。程序中的某个任务因为某些问题导致不能继续执行，由于没有并发，所以整个程序都将停止下来，直到问题解决才能继续执行。但是，如果使用并发编程，那么当任务阻塞时，程序的其他任务依然可以继续执行。从性能的角度看，这也是使用并发编程的意义。 1.进程和线程 进程：是正在执行中的程序，每一个进程都有一个执行的顺序，该顺序是一个执行路径 ，或者称为一个控制单元 。 线程：是进程 中的独立控制单元，线程控制着进程的执行。 每个进程中至少存在一个线程 java 虚拟机启动的时候会有一个进程，该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main 方法中，该线程又称为主线程。 jvm启动时，负责垃圾回收机制的线程也同时启动。 2.如何自定义一个线程创建新执行线程有两种方法1.将类声明为 Thread 的子类 定义类继承Thread类。 重写Thread类中的run方法。 1234567891011class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; 使用线程的start方法，创建、启动线程。 12PrimeThread p = new PrimeThread(143); p.start(); 2.声明实现 Runnable 接口的类 自定义类实现Runnable的接口。 实现接口中的run 方法。 1234567891011class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; 创建自定义类的实例，将其作为参数传递到Thread 中并启动线程. 12PrimeRun p = new PrimeRun(143); new Thread(p).start(); 3.继承和接口方法主要区别​ 继承Thread：线程代码存放在Thread子类的run方法中。 ​ 实现Runnable：线程代码存放在接口自类的run方法中。 ​ Runnable实现方式避免了单继承的局限性，建议使用。 3.线程安全&gt;线程不安全：由于没有对资源进行访问保护，多个线程同时访问并重复修改资源使资源产生错误。 &gt; &gt;线程安全：当多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 ​ 举个例子：去公共厕所时，当你刚进去正要脱裤子，突然有一个人进来也要上厕所，这时你俩就很尴尬了。如果你一进门先把厕所的门锁上，其他人就进不来这就比较好的避免了尴尬。 ​ 在线程中这个锁就是synchronized 关键字，synchronized 关键字在通过编译之后，会在同步块前后分别形成monitorentor 和monitorexit两个字节码指令，这个两个指令都需要一个reference 类型来指明要锁定和解锁的对象，如果synchnronized 明确指定了对象参数，那就是这个对象的reference ，如果没有指明，那么就根据synchronied 修饰的是实例方法还是类方法，然后取对应对象的实例或者Class对象那个作为锁对象。 synchronized关键字使用 同步代码块 123456789101112131415class Ticket implements Runnable&#123; private int t = 100; //假设有一百张票 Object o = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (o)&#123; //加入同步代码块 if(t&gt;0) &#123; System.out.println(Thread.currentThread .getName+" : "+ t--); &#125; &#125; &#125; &#125;&#125; 同步函数 12345678910111213141516class Ticket implements Runnable&#123; private int t = 100; //假设有一百张票 Object o = new Object(); @Override public void run() &#123; while(true)&#123; show(); &#125; &#125; &#125; public synchronized void show()&#123; //使用同步函数 if(t&gt;0)&#123; System.out.println(Thread.currentThread().getName() +" : "+ t--); &#125;&#125; &gt;当在函数中使用synchronized其实是否还存在对象锁？ &gt; &gt;存在的，他的锁其实就是他对象本身（this），当函数为静态时，锁则为他的Class对象。 ​]]></content>
    </entry>

    
  
  
</search>
