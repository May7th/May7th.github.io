<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[[leetcode]Distribute Candies]]></title>
      <url>%2F2017%2F05%2F09%2FDistribute-Candies%20copy%2F</url>
      <content type="text"><![CDATA[Distribute Candies题目大意： 每个数字代表一种糖果。共偶数个糖果，平分给弟弟妹妹，如何让妹妹获得最多种类的糖果？ Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Example 1: 123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. Example 2: 1234Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies. 解题思路： 比较糖果种类和半数糖果的大小，如果半数糖果大则返回糖果种类，否则返回半数糖果。 代码如下： 123456789public class Solution &#123; public int distributeCandies(int[] candies) &#123; Set dif = new HashSet(); for(Integer i:candies)&#123; dif.add(i); &#125; return (dif.size()&gt;candies.length/2 ? candies.length/2 : dif.size()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[leetcode]Array Partition]]></title>
      <url>%2F2017%2F05%2F08%2Fleetcode-Array-Partition%20copy%2F</url>
      <content type="text"><![CDATA[Array Partition I题目大意： 给定一个长度为2n的数组，将它分为n个小组，每组两个元素。求出每组中最小值和，返回其中最大的和sum。 Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4. Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 解题思路： 先排序，将相邻两个数分为一组，每组较小数都在左边，求和即可 算法分析： 假设对于每一对i，bi &gt;= ai。 定义Sm = min（a1，b1）+ min（a2，b2）+ … + min（an，bn）。最大的Sm是这个问题的答案。由于bi &gt;= ai，Sm = a1 + a2 + … + an。 定义Sa = a1 + b1 + a2 + b2 + … + an + bn。对于给定的输入，Sa是常数。 定义di = | ai - bi |。由于bi &gt;= ai，di = bi-ai, bi = ai+di。 定义Sd = d1 + d2 + … + dn。 所以Sa = a1 + (a1 + d1) + a2 + (a2 + d2) + … + an + (an + di) = 2Sm + Sd , 所以Sm =（Sa-Sd）/ 2。为得到最大Sm，给定Sa为常数，需要使Sd尽可能小。 所以这个问题就是在数组中找到使di（ai和bi之间的距离）的和尽可能小的对。显然，相邻元素的这些距离之和是最小的。 代码如下： 12345678910public class Solution &#123; public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int num = 0; for(int i = 0;i &lt; nums.length;i+=2)&#123; num +=nums[i]; &#125; return num; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【java基础知识】并发]]></title>
      <url>%2F2017%2F04%2F17%2F%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%E5%B9%B6%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[编程问题中相当大的部分都可以通过顺序编程来解决，但是对于一些问题，如果能够并行地执行程序中的多个部分，就会变得非常方便。 假如想要一个程序运行的更快，那么就应该将其分成多个片段，在单独的处理器上运行每个片段来提高速度。但是，并发通常也可以提高单处理器 运行程序的性能。 ​ 由于增加了上下文切换的代价，在单处理器上并发运行的开销其实是要比顺序运行的开销更大的，但是，在顺序运行时可能会有其他更严重的问题——程序阻塞。程序中的某个任务因为某些问题导致不能继续执行，由于没有并发，所以整个程序都将停止下来，直到问题解决才能继续执行。但是，如果使用并发编程，那么当任务阻塞时，程序的其他任务依然可以继续执行。从性能的角度看，这也是使用并发编程的意义。 1.进程和线程 进程：是正在执行中的程序，每一个进程都有一个执行的顺序，该顺序是一个执行路径 ，或者称为一个控制单元 。 线程：是进程 中的独立控制单元，线程控制着进程的执行。 每个进程中至少存在一个线程 java 虚拟机启动的时候会有一个进程，该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main 方法中，该线程又称为主线程。 jvm启动时，负责垃圾回收机制的线程也同时启动。 2.如何自定义一个线程创建新执行线程有两种方法1.将类声明为 Thread 的子类 定义类继承Thread类。 重写Thread类中的run方法。 1234567891011class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; 使用线程的start方法，创建、启动线程。 12PrimeThread p = new PrimeThread(143); p.start(); 2.声明实现 Runnable 接口的类 自定义类实现Runnable的接口。 实现接口中的run 方法。 1234567891011class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; 创建自定义类的实例，将其作为参数传递到Thread 中并启动线程. 12PrimeRun p = new PrimeRun(143); new Thread(p).start(); 3.继承和接口方法主要区别​ 继承Thread：线程代码存放在Thread子类的run方法中。 ​ 实现Runnable：线程代码存放在接口自类的run方法中。 ​ Runnable实现方式避免了单继承的局限性，建议使用。 3.线程安全&gt;线程不安全：由于没有对资源进行访问保护，多个线程同时访问并重复修改资源使资源产生错误。 &gt; &gt;线程安全：当多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 ​ 举个例子：去公共厕所时，当你刚进去正要脱裤子，突然有一个人进来也要上厕所，这时你俩就很尴尬了。如果你一进门先把厕所的门锁上，其他人就进不来这就比较好的避免了尴尬。 ​ 在线程中这个锁就是synchronized 关键字，synchronized 关键字在通过编译之后，会在同步块前后分别形成monitorentor 和monitorexit两个字节码指令，这个两个指令都需要一个reference 类型来指明要锁定和解锁的对象，如果synchnronized 明确指定了对象参数，那就是这个对象的reference ，如果没有指明，那么就根据synchronied 修饰的是实例方法还是类方法，然后取对应对象的实例或者Class对象那个作为锁对象。 synchronized关键字使用 同步代码块 123456789101112131415class Ticket implements Runnable&#123; private int t = 100; //假设有一百张票 Object o = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (o)&#123; //加入同步代码块 if(t&gt;0) &#123; System.out.println(Thread.currentThread .getName+" : "+ t--); &#125; &#125; &#125; &#125;&#125; 同步函数 12345678910111213141516class Ticket implements Runnable&#123; private int t = 100; //假设有一百张票 Object o = new Object(); @Override public void run() &#123; while(true)&#123; show(); &#125; &#125; &#125; public synchronized void show()&#123; //使用同步函数 if(t&gt;0)&#123; System.out.println(Thread.currentThread().getName() +" : "+ t--); &#125;&#125; &gt;当在函数中使用synchronized其实是否还存在对象锁？ &gt; &gt;存在的，他的锁其实就是他对象本身（this），当函数为静态时，锁则为他的Class对象。 ​]]></content>
    </entry>

    
  
  
</search>
